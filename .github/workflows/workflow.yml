name: Dynamic Institution Deploy to S3

on:
  push:
    branches:
      - '*'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Install Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '20'

      - name: Install dependencies
        run: yarn

      - name: Setup Environment Files
        if: steps.config.outputs.should_deploy == 'true'
        run: |
          # Ensure both files exist
          touch .env
          touch .env.production
          
          # Remove any BOM characters and extra whitespace
          sed -i 's/\r$//' .env
          sed -i 's/\r$//' .env.production
          
          # Create a temporary file for merged content
          touch .env.temp
          
          # Process and merge environment files
          while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            
            # Extract the variable name
            var_name=$(echo "$line" | cut -d'=' -f1)
            
            # If this is a JSON variable, ensure it's on one line
            if [[ "$var_name" == "REACT_APP_INSTITUTION_DATA" ]] || [[ "$var_name" == "REACT_APP_META_TAGS" ]]; then
              # Capture all lines until we find a complete JSON object
              json_content=""
              while IFS= read -r json_line || [[ -n "$json_line" ]]; do
                json_content+="$json_line"
                if [[ "$json_content" =~ ^\{.*\}$ ]]; then
                  break
                fi
              done
              # Write the complete JSON on a single line
              echo "$var_name=$json_content" >> .env.temp
            else
              echo "$line" >> .env.temp
            fi
          done < .env
          
          # Do the same for .env.production, overwriting any duplicate variables
          while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            var_name=$(echo "$line" | cut -d'=' -f1)
            
            if [[ "$var_name" == "REACT_APP_INSTITUTION_DATA" ]] || [[ "$var_name" == "REACT_APP_META_TAGS" ]]; then
              json_content=""
              while IFS= read -r json_line || [[ -n "$json_line" ]]; do
                json_content+="$json_line"
                if [[ "$json_content" =~ ^\{.*\}$ ]]; then
                  break
                fi
              done
              # Remove any existing value and add the new one
              sed -i "/^$var_name=/d" .env.temp
              echo "$var_name=$json_content" >> .env.temp
            else
              # Remove any existing value and add the new one
              sed -i "/^$var_name=/d" .env.temp
              echo "$line" >> .env.temp
            fi
          done < .env.production
          
          # Replace the original .env with our merged content
          mv .env.temp .env
          
          echo "Environment files merged successfully"
          echo "Preview of environment variables (excluding sensitive data):"
          grep -v "_SECRET\|_KEY\|_TOKEN" .env || true

      - name: Create temp config reader
        run: |
          echo '{"type": "module"}' > temp-package.json
          echo 'import fs from "fs";
          
          try {
            const envContent = fs.readFileSync(".env", "utf8");
            
            // Helper function to extract JSON from env content
            const extractJSON = (envContent, varName) => {
              const match = envContent.match(new RegExp(`${varName}=({[\\s\\S]*?})(?:\\n|$)`));
              return match ? JSON.parse(match[1]) : null;
            };
            
            const data = extractJSON(envContent, "REACT_APP_INSTITUTION_DATA");
            if (!data) {
              throw new Error("Could not find or parse REACT_APP_INSTITUTION_DATA");
            }
            
            const { institutionId } = data;
            if (!institutionId) {
              throw new Error("institutionId is missing from data");
            }
            
            const parts = institutionId.split(/(\d+)/).filter(Boolean);
            const institutionName = parts[0];
            
            const branch = process.env.GITHUB_REF.split("/").pop();
            const stage = branch.startsWith("beta-") ? "DEV" : "PROD";
            
            const deployment = {
              [`beta-${institutionName}`]: {
                s3Bucket: `beta.${institutionName}.com`,
                cloudfrontId: data.cloudFrontId
              },
              [institutionName]: {
                s3Bucket: `${institutionName}.com`,
                cloudfrontId: data.cloudFrontId
              }
            };
            
            const config = deployment[branch];
            console.log(JSON.stringify({
              s3Bucket: config ? config.s3Bucket : "",
              cloudfrontId: config ? config.cloudfrontId : "",
              shouldDeploy: !!config,
              reactAppStage: stage
            }));
          } catch (error) {
            console.error("Error in config reader:", error.message);
            process.exit(1);
          }' > configReader.mjs

      - name: Get deployment configuration
        id: config
        run: |
          cp package.json original-package.json
          cp temp-package.json package.json
          CONFIG_JSON=$(node configReader.mjs)
          cp original-package.json package.json
          echo "s3_bucket=$(echo $CONFIG_JSON | jq -r .s3Bucket)" >> $GITHUB_OUTPUT
          echo "cloudfront_id=$(echo $CONFIG_JSON | jq -r .cloudfrontId)" >> $GITHUB_OUTPUT
          echo "should_deploy=$(echo $CONFIG_JSON | jq -r .shouldDeploy)" >> $GITHUB_OUTPUT
          echo "react_app_stage=$(echo $CONFIG_JSON | jq -r .reactAppStage)" >> $GITHUB_OUTPUT

      - name: Build the React app
        if: steps.config.outputs.should_deploy == 'true'
        env:
          CI: false
          GENERATE_SOURCEMAP: false
        run: |
          export NODE_OPTIONS=--max_old_space_size=4096
          echo "Building React app with merged environment variables..."
          yarn build

      - name: Set up AWS CLI
        if: steps.config.outputs.should_deploy == 'true'
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy to S3
        if: steps.config.outputs.should_deploy == 'true'
        run: |
          echo "Starting S3 sync to bucket: ${{ steps.config.outputs.s3_bucket }}"
          aws s3 sync ./build s3://${{ steps.config.outputs.s3_bucket }} --delete
          echo "S3 sync completed"

      - name: Cloudfront Invalidation
        if: steps.config.outputs.should_deploy == 'true'
        run: |
          echo "Creating CloudFront invalidation for distribution: ${{ steps.config.outputs.cloudfront_id }}"
          aws cloudfront create-invalidation --distribution-id ${{ steps.config.outputs.cloudfront_id }} --paths "/*"
          echo "CloudFront invalidation created"